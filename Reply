# padded_reconstruct_clip_unique_plot_intra_fallback.py
import os, math, glob, tqdm, time, uuid
import numpy as np
from PIL import Image
import torch
import torch.nn.functional as F
from src.models.video_model import DMC as VideoModel

# live-plot imports
from IPython.display import display, update_display
import matplotlib
matplotlib.use('module://matplotlib_inline.backend_inline')
import matplotlib.pyplot as plt

# ----------------------
# Config / Paths (edit)
# ----------------------
ckpt_path = "./checkpoints_new_lambda0.01/best_epoch002.pth.tar"
frames_dir = "data/frames/train/clip_01"
out_dir = "outputs/recon_frames/new_train/1_clip_01_padded_intra_fallback"
os.makedirs(out_dir, exist_ok=True)

# Optional: human run name to identify the plot (can be '')
run_name = ""  # e.g. "run_lr1e-4" or leave empty

# DPB refresh frequency (0 disables periodic refresh)
REFRESH_N = 30  # your previous value; adjust if desired

# Bad-frame detection and fallback parameters
MSE_HISTORY_LEN = 16
BAD_MSE_FACTOR = 8.0          # relative threshold (current_mse > BAD_MSE_FACTOR * median(history))
BAD_MSE_MIN = 1e-8            # avoid divide-by-zero for very small medians
CONSECUTIVE_BAD_LIMIT = 5    # if this many bad frames in a row occur, enable intra-only fallback
INTRA_MODE_FRAMES = 10       # number of frames to process in intra-only mode after triggering
MAX_ALLOWED_NONFINITE = 0     # if any nonfinite pixel found in reconstruction treat as bad

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("device:", device)

# Load model
model = VideoModel().to(device).eval()
if os.path.exists(ckpt_path):
    ck = torch.load(ckpt_path, map_location="cpu")
    sd = ck.get("state_dict", ck)
    model.load_state_dict({k.replace("module.",""): v for k,v in sd.items()}, strict=False)
    print("Loaded checkpoint:", ckpt_path)
else:
    print("Warning: checkpoint not found:", ckpt_path)

# Helper: PSNR
def mse_to_psnr(mse, max_val=1.0):
    if not np.isfinite(mse) or mse <= 0:
        return float("inf") if mse == 0 else float("nan")
    return 10.0 * math.log10((max_val**2) / mse)

# get frame list
frame_paths = sorted(glob.glob(os.path.join(frames_dir, "*.png")))
if len(frame_paths) == 0:
    raise SystemExit(f"No frames found in {frames_dir}")

# initialize dpb
try:
    model.clear_dpb()
except Exception:
    model.dpb = []

psnr_list = []
mse_list = []

# stability tracking
mse_history = []
last_good_frame = None
consecutive_bad = 0
intra_mode_counter = 0
intra_mode_active = False

# --------------------------
# Create a unique display id
# --------------------------
timestamp_ms = int(time.time() * 1000)
unique_token = uuid.uuid4().hex[:8]
_display_id_str = f"psnr_plot_{timestamp_ms}_{unique_token}"
if run_name:
    _display_id_str = f"{_display_id_str}_{run_name}"
print("Live PSNR plot display_id:", _display_id_str)

# Prepare matplotlib figure
fig, ax = plt.subplots(figsize=(10, 3))
ax.set_title("PSNR per frame (live) â€” " + (_display_id_str if run_name == "" else run_name))
ax.set_xlabel("frame index")
ax.set_ylabel("PSNR (dB)")
ax.grid(True)
line, = ax.plot([], [], marker='o', markersize=3, linestyle='-', linewidth=0.7)
ax.set_xlim(0, max(10, len(frame_paths)))
ax.set_ylim(0, 50)

# display once (creates persistent output cell)
try:
    display(fig, display_id=_display_id_str)
    plt.close(fig)
except Exception:
    pass

# --------------------------
# Main per-frame loop
# --------------------------
for i, p in enumerate(tqdm.tqdm(frame_paths, desc="Frames")):
    im = Image.open(p).convert("RGB")
    arr = np.asarray(im, dtype=np.float32)/255.0
    H, W = arr.shape[0], arr.shape[1]

    x = torch.from_numpy(arr.transpose(2,0,1))[None,...].to(device)  # [1,C,H,W]

    pad_h = (16 - (H % 16)) % 16
    pad_w = (16 - (W % 16)) % 16
    pad = (0, pad_w, 0, pad_h)
    if pad_w != 0 or pad_h != 0:
        x_padded = F.pad(x, pad, mode='replicate')
    else:
        x_padded = x

    # For first frame ensure dpb has a zero frame with same padded dims
    if i == 0:
        zeros = torch.zeros_like(x_padded)
        try:
            model.clear_dpb()
        except Exception:
            model.dpb = []
        try:
            model.add_ref_frame(frame=zeros, increase_poc=False)
        except Exception:
            try:
                model.add_ref_frame(feature=None, frame=zeros, increase_poc=False)
            except Exception:
                model.dpb = []
                model.add_ref_frame(frame=zeros, increase_poc=False)

    # Decide whether to operate in intra-only mode
    if intra_mode_active:
        # intra-only: clear DPB (no temporal references) and reconstruct frame independently
        try:
            model.clear_dpb()
        except Exception:
            model.dpb = []
    # Run best-effort differentiable encoder/decoder path (no entropy coder used here)
    with torch.no_grad():
        try:
            feat_adapt = model.apply_feature_adaptor()
        except Exception:
            try:
                feat_in = F.pixel_unshuffle(x_padded, 8)
            except Exception:
                feat_in = x_padded
            try:
                feat_adapt = model.feature_adaptor_i(feat_in)
            except Exception:
                feat_adapt = feat_in

        ctx = None; ctx_t = None
        if hasattr(model, "feature_extractor"):
            try:
                qf = model.q_feature[0:1] if hasattr(model,"q_feature") else None
                ctx, ctx_t = model.feature_extractor(feat_adapt, qf)
            except Exception:
                ctx, ctx_t = (None, None)

        y = None
        if hasattr(model, "encoder"):
            try:
                q_enc = model.q_encoder[0:1] if hasattr(model,"q_encoder") else None
                y = model.encoder(x_padded, ctx if ctx is not None else feat_adapt, q_enc)
            except Exception:
                y = None

        x_hat_padded = x_padded
        feat_dec = None
        if y is not None and hasattr(model, "decoder") and hasattr(model, "recon_generation_net"):
            try:
                q_dec = model.q_decoder[0:1] if hasattr(model,"q_decoder") else None
                q_recon = model.q_recon[0:1] if hasattr(model,"q_recon") else None
                feat_dec = model.decoder(y, ctx if ctx is not None else feat_adapt, q_dec)
                x_hat_padded = model.recon_generation_net(feat_dec, q_recon).clamp(0,1)
            except Exception:
                x_hat_padded = x_padded

    # SANITIZE non-finite or extreme values
    try:
        if not torch.isfinite(x_hat_padded).all() or (torch.isfinite(x_hat_padded).sum().item() <= MAX_ALLOWED_NONFINITE):
            # very bad: replace with last_good_frame or clamp
            if last_good_frame is not None:
                x_hat_padded = last_good_frame.clone()
            else:
                x_hat_padded = torch.clamp(torch.nan_to_num(x_hat_padded, nan=0.0, posinf=1.0, neginf=0.0), 0.0, 1.0)
        x_hat_padded = torch.clamp(x_hat_padded, 0.0, 1.0)
    except Exception:
        x_hat_padded = torch.clamp(x_padded, 0.0, 1.0)

    # crop back to original H,W
    x_hat = x_hat_padded[..., :H, :W]

    # compute mse/psnr
    mse = float(F.mse_loss(x_hat, x, reduction="mean").item())
    psnr = mse_to_psnr(mse)

    # Update history
    mse_history.append(mse)
    if len(mse_history) > MSE_HISTORY_LEN:
        mse_history.pop(0)

    # Bad-frame detection (relative to history)
    is_bad = False
    if not np.isfinite(mse):
        is_bad = True
    else:
        if len(mse_history) >= 3:
            med = float(np.median(mse_history))
            if med > BAD_MSE_MIN and mse > BAD_MSE_FACTOR * med:
                is_bad = True

    # If bad -> replace with last_good_frame (if possible). Do NOT add bad frame to DPB.
    if is_bad:
        consecutive_bad += 1
        if last_good_frame is not None:
            x_hat_padded = last_good_frame.clone()
            x_hat = x_hat_padded[..., :H, :W]
            mse = float(F.mse_loss(x_hat, x, reduction="mean").item())
            psnr = mse_to_psnr(mse)
        else:
            # fallback identity
            x_hat_padded = torch.clamp(x_padded, 0.0, 1.0)
            x_hat = x_hat_padded[..., :H, :W]
            mse = float(F.mse_loss(x_hat, x, reduction="mean").item())
            psnr = mse_to_psnr(mse)
        print(f"Warning: bad frame {i} detected (mse large or non-finite). Replaced with last_good_frame or input.")
    else:
        consecutive_bad = 0
        # good frame -> update last_good_frame and add to DPB unless we are in intra-mode
        try:
            last_good_frame = x_hat_padded.clone().detach()
        except Exception:
            last_good_frame = None

        if not intra_mode_active:
            try:
                if feat_dec is not None:
                    model.add_ref_frame(feature=feat_dec, frame=x_hat_padded, increase_poc=True)
                else:
                    model.add_ref_frame(frame=x_hat_padded, increase_poc=True)
            except Exception:
                try:
                    model.add_ref_frame(frame=x_hat_padded, increase_poc=True)
                except Exception:
                    pass
        else:
            # intra mode: we DON'T add to DPB (keeps DPB empty)
            pass

    # If many consecutive bad frames, enter intra-only fallback mode for a while
    if consecutive_bad >= CONSECUTIVE_BAD_LIMIT and not intra_mode_active:
        intra_mode_active = True
        intra_mode_counter = INTRA_MODE_FRAMES
        print(f"*** Entering INTRA-ONLY fallback for {INTRA_MODE_FRAMES} frames (triggered at frame {i}). ***")
        # clear DPB now to avoid using poisoned refs
        try:
            model.clear_dpb()
        except Exception:
            model.dpb = []

    # If in intra-mode count down and exit when done
    if intra_mode_active:
        intra_mode_counter -= 1
        if intra_mode_counter <= 0:
            intra_mode_active = False
            consecutive_bad = 0
            # Re-init DPB with last_good_frame if available
            try:
                if last_good_frame is not None:
                    model.clear_dpb()
                    model.add_ref_frame(frame=last_good_frame, increase_poc=False)
                else:
                    model.clear_dpb()
            except Exception:
                pass
            print(f"*** Exited INTRA-ONLY fallback at frame {i}. Resuming normal mode. ***")

    # Periodic DPB refresh (simulate an I-frame) using last_good_frame when possible
    if REFRESH_N > 0 and (i + 1) % REFRESH_N == 0:
        try:
            ref_for_refresh = last_good_frame.clone().detach() if last_good_frame is not None else torch.zeros_like(x_padded)
            try:
                model.clear_dpb()
            except Exception:
                model.dpb = []
            try:
                model.add_ref_frame(frame=ref_for_refresh, increase_poc=False)
            except Exception:
                try:
                    model.add_ref_frame(feature=None, frame=ref_for_refresh, increase_poc=False)
                except Exception:
                    model.dpb = []
                    model.add_ref_frame(frame=ref_for_refresh, increase_poc=False)
            print(f"--- DPB refresh at frame {i+1} using {'last_good_frame' if last_good_frame is not None else 'zeros'} ---")
        except Exception as e:
            print(f"DPB refresh failed at frame {i+1}: {e}")

    # Save reconstructed frame (guard against invalid values)
    out_np = (np.clip(x_hat[0].cpu().numpy().transpose(1,2,0), 0.0, 1.0) * 255.0).round().astype(np.uint8)
    Image.fromarray(out_np).save(os.path.join(out_dir, f"frame_{i:05d}.png"))

    # Minimal prints for first few frames
    if i < 3:
        print(f"frame {i}: mse={mse:.6e} psnr={psnr if np.isfinite(psnr) else 'inf'} saved -> {os.path.join(out_dir, f'frame_{i:05d}.png')}")

    # Update live PSNR plot
    try:
        line.set_xdata(np.arange(len(psnr_list) + 1))
        line.set_ydata(np.array(psnr_list + [psnr]))
        ax.relim()
        ax.autoscale_view()
        update_display(fig, display_id=_display_id_str)
        plt.pause(0.001)
    except Exception:
        pass

    # Append histories
    mse_list.append(mse)
    psnr_list.append(psnr)

# summary
finite_psnrs = [p for p in psnr_list if np.isfinite(p)]
avg_mse = float(np.mean(mse_list)) if len(mse_list) > 0 else float('nan')
avg_psnr = float(np.mean(finite_psnrs)) if len(finite_psnrs)>0 else float('nan')
print("Done. frames:", len(frame_paths), "avg_mse:", avg_mse, "avg_psnr (finite only):", avg_psnr)
print("Saved reconstructed frames to:", out_dir)
