#!/usr/bin/env python3
"""
decoder.py - decode frame-by-frame bitstreams produced by encoder.py

Usage example:
PYTHONPATH=$PWD python decoder.py \
  --encoded-dir encoded/clip_01_bits \
  --out-dir decoded/clip_01_dec \
  --ckpt ./checkpoints_new_lambda0.01/best_epoch026.pth.tar \
  --device cuda \
  --compute-psnr --orig-frames data/frames/train/clip_01
"""
import os
import sys
import json
import argparse
from pathlib import Path
from glob import glob
from tqdm import tqdm
import math

import numpy as np
from PIL import Image

import torch
import torch.nn.functional as F

# Import model (same class used for encoder)
try:
    from src.models.video_model import DMC as VideoModel
except Exception as e:
    print("ERROR: failed to import VideoModel from src.models.video_model:", e, file=sys.stderr)
    raise

def load_checkpoint_into_model(model, ckpt_path):
    ck = torch.load(ckpt_path, map_location='cpu')
    sd = ck.get('state_dict', ck)
    sd = {k.replace('module.', ''): v for k,v in sd.items()}
    model.load_state_dict(sd, strict=False)

def try_model_update(model):
    """
    Try to call model.update() to initialize entropy coder if present.
    Returns True if decompress path is likely to work, False otherwise.
    """
    try:
        model.update()
        # quick sanity check: entropy_coder exists on model
    except Exception:
        pass
    ok = getattr(model, "entropy_coder", None) is not None
    if not ok:
        # try other attached objects
        be = getattr(model, "bit_estimator_z", None)
        ge = getattr(model, "gaussian_encoder", None)
        ok = (be is not None and getattr(be, "entropy_coder", None) is not None) or \
             (ge is not None and getattr(ge, "entropy_coder", None) is not None)
    return bool(ok)

def mse_to_psnr(mse, max_val=1.0):
    if mse <= 0 or not np.isfinite(mse):
        return float('inf') if mse == 0 else float('nan')
    return 10.0 * math.log10((max_val**2) / mse)

def read_png(path):
    im = Image.open(path).convert("RGB")
    arr = np.asarray(im, dtype=np.float32) / 255.0
    # return [1,C,H,W] float32 torch tensor (cpu)
    t = torch.from_numpy(arr.transpose(2,0,1))[None,...]
    return t

def save_png_from_tensor(tensor, out_path):
    # tensor [1,C,H,W] in [0,1], CPU or CUDA
    arr = tensor[0].detach().cpu().numpy().transpose(1,2,0)
    arr = np.clip(arr, 0.0, 1.0)
    out_np = (arr * 255.0).round().astype(np.uint8)
    Image.fromarray(out_np).save(str(out_path))

def main():
    p = argparse.ArgumentParser()
    p.add_argument('--encoded-dir', required=True, help="Directory with manifest.json and frame_XXXXX.bin + PNGs.")
    p.add_argument('--out-dir', required=True, help="Directory to write decoded/reconstructed frames.")
    p.add_argument('--ckpt', required=False, help="Path to model checkpoint (.pth.tar). If omitted, model loaded without pretrained weights.")
    p.add_argument('--device', default='cuda', help="Device to run on (cuda or cpu).")
    p.add_argument('--compute-psnr', action='store_true', help="If provided, compute PSNR vs original frames provided by --orig-frames.")
    p.add_argument('--orig-frames', default='', help="Folder with original PNG frames (for PSNR calculation).")
    p.add_argument('--skip-decompress-on-missing-coder', action='store_true',
                   help="If set, skip attempting model.decompress() when compiled coder not available and directly use encoder-saved PNGs.")
    args = p.parse_args()

    encoded_dir = Path(args.encoded_dir)
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    manifest_path = encoded_dir / "manifest.json"
    if not manifest_path.exists():
        print("manifest.json not found in encoded dir:", encoded_dir)
        return

    with open(manifest_path, 'r') as f:
        manifest = json.load(f)

    frame_meta = manifest.get("frame_meta", [])
    if len(frame_meta) == 0:
        print("manifest contains no frames.")
        return

    device = torch.device(args.device if (args.device == 'cpu' or torch.cuda.is_available()) else 'cpu')
    print("device:", device)

    # load model
    model = VideoModel().to(device).eval()
    if args.ckpt:
        if os.path.exists(args.ckpt):
            try:
                load_checkpoint_into_model(model, args.ckpt)
                print("Loaded checkpoint:", args.ckpt)
            except Exception as e:
                print("Warning: failed to fully load checkpoint:", e)
        else:
            print("Warning: checkpoint not found:", args.ckpt)

    # Try to init compiled coder if available
    codec_ready = try_model_update(model)
    if codec_ready:
        print("Compiled codec backend appears available â€” will attempt model.decompress() for frames with had_bitstream=True.")
    else:
        print("Compiled codec backend NOT available or not initialized.")
        if args.skip_decompress_on_missing_coder:
            print("skip-decompress-on-missing-coder set: will use encoder-saved PNGs when had_bitstream==False (or when decompress fails).")

    # prepare original frame list for PSNR if requested
    orig_paths = []
    if args.compute_psnr:
        if args.orig_frames:
            orig_paths = sorted(glob(str(Path(args.orig_frames) / "*.png")))
            if len(orig_paths) < len(frame_meta):
                print("Warning: fewer original frames found than encoded frames; PSNR will be computed for matching indices only.")
        else:
            print("PSNR requested but no --orig-frames provided; skipping PSNR.")
            args.compute_psnr = False

    psnr_list = []
    mse_list = []
    bad_frames = 0

    for meta in tqdm(frame_meta, desc="Decoding frames"):
        i = int(meta.get("index", 0))
        bin_name = meta.get("filename")
        had_bitstream = bool(meta.get("had_bitstream", False))
        H = int(meta.get("orig_height", 0))
        W = int(meta.get("orig_width", 0))
        pad_h = int(meta.get("pad_h", 0))
        pad_w = int(meta.get("pad_w", 0))

        bin_path = encoded_dir / bin_name
        recovered = None

        # Prefer decompress via model if we have a bitstream and coder looks available
        if had_bitstream and codec_ready:
            try:
                with open(bin_path, 'rb') as f:
                    bs = f.read()
                if bs and len(bs) > 0:
                    # call decompress -> expect dict with 'x_hat' possibly padded
                    try:
                        sps = {'height': H, 'width': W, 'ec_part': 0}
                        dec = model.decompress(bs, sps, int(manifest.get("qp", 0)))
                        x_hat = dec.get('x_hat', None)
                        if x_hat is not None:
                            # ensure CPU/GPU device alignment and crop to original
                            if isinstance(x_hat, torch.Tensor):
                                x_hat = x_hat.to(device)
                                # If padded shape, crop bottom/right
                                _, _, Hhat, What = x_hat.shape
                                if Hhat >= H and What >= W:
                                    x_hat = x_hat[..., :H, :W]
                            recovered = x_hat
                        else:
                            # some models place recon in another key or returned PNGs; fallback
                            recovered = None
                    except Exception as e:
                        print(f"model.decompress() failed for frame {i}: {e}")
                        recovered = None
                else:
                    # empty file -> treat as no-bitstream
                    recovered = None
            except FileNotFoundError:
                recovered = None

        # If decompress not done or failed: try to load the PNG saved by encoder
        if recovered is None:
            # look for reconstructed PNG that encoder saved
            png_path = encoded_dir / f"frame_{i:05d}.png"
            if png_path.exists():
                try:
                    recovered = read_png(png_path).to(device)
                except Exception as e:
                    print(f"Failed to read encoder-saved PNG for frame {i} at {png_path}: {e}")
                    recovered = None
            else:
                # nothing left to do: create a zero placeholder or copy of original if available
                if args.compute_psnr and len(orig_paths) > i:
                    recovered = read_png(orig_paths[i]).to(device)
                else:
                    # create black frame
                    recovered = torch.zeros((1,3,H if H>0 else 1, W if W>0 else 1), dtype=torch.float32, device=device)

        # clamp and crop safety
        try:
            recovered = torch.clamp(recovered, 0.0, 1.0)
            # ensure shape matches H,W
            if recovered.shape[2] < H or recovered.shape[3] < W:
                # pad up (rare) or replicate
                pad_h_need = max(0, H - recovered.shape[2])
                pad_w_need = max(0, W - recovered.shape[3])
                pad = (0, pad_w_need, 0, pad_h_need)
                recovered = F.pad(recovered, pad, mode='replicate')
            recovered = recovered[..., :H, :W]
        except Exception as e:
            print(f"Postprocess failed for frame {i}: {e}")
            bad_frames += 1
            continue

        # save reconstructed PNG to output dir
        out_png = out_dir / f"frame_{i:05d}.png"
        try:
            save_png_from_tensor(recovered, out_png)
        except Exception as e:
            print(f"Failed to save decoded PNG for frame {i}: {e}")

        # PSNR vs original if requested
        if args.compute_psnr and len(orig_paths) > i:
            orig_t = read_png(orig_paths[i]).to(device)
            # crop orig to H,W if needed
            orig_t = orig_t[..., :H, :W]
            mse = float(F.mse_loss(recovered, orig_t, reduction='mean').item())
            psnr = mse_to_psnr(mse)
            mse_list.append(mse)
            if np.isfinite(psnr):
                psnr_list.append(psnr)
            else:
                # record NaN but continue
                psnr_list.append(float('nan'))
        else:
            mse_list.append(0.0)
            psnr_list.append(float('nan'))

    # summary
    finite_psnrs = [p for p in psnr_list if np.isfinite(p)]
    avg_mse = float(np.nanmean(mse_list)) if len(mse_list) > 0 else float('nan')
    avg_psnr = float(np.nanmean(finite_psnrs)) if len(finite_psnrs) > 0 else float('nan')
    print("Done. frames decoded:", len(frame_meta))
    print("Average MSE:", avg_mse)
    print("Average PSNR (finite only):", avg_psnr)

    if args.compute_psnr:
        # save psnr CSV
        out_csv = out_dir / "psnr_per_frame.csv"
        with open(out_csv, 'w') as f:
            f.write("frame_index,mse,psnr\n")
            for idx, (m, p) in enumerate(zip(mse_list, psnr_list)):
                f.write(f"{idx},{m},{p}\n")
        print("Per-frame PSNR saved to:", out_csv)

    # print ffmpeg suggestion (user may not have ffmpeg in PATH)
    print()
    print("To assemble decoded frames into a video (example using ffmpeg):")
    print(f"  ffmpeg -y -framerate 30 -i {out_dir}/frame_%05d.png -c:v libx264 -pix_fmt yuv420p {out_dir}/recon_video.mp4")

if __name__ == "__main__":
    main()
